#!/usr/bin/env ruby

require 'logging'
require 'matrix_releasetracker'
require 'net/http'

def fix_media_url(url, config)
  config.media[url] ||= begin
    data = Net::HTTP.get_response(URI(url))

    config.client.media_upload(data.body, data.content_type)[:content_uri] if data.is_a? Net::HTTPOK
  end
end

if $PROGRAM_NAME == __FILE__
  config = MatrixReleasetracker::Config.load!
  STDERR.puts "[#{Time.now.strftime '%F %T'}] Loaded configuration."

  # MatrixSdk.debug!
  Logging.logger['MatrixReleasetracker'].tap do |logger|
    logger.add_appenders Logging.appenders.stdout
    logger.level = :debug # :warn
  end

  STDERR.puts "[#{Time.now.strftime '%F %T'}] Ensuring configured rooms are joined."
  config.backends.map { |_k, b| b.users.map { |u| u[:room] } }.flatten.uniq.each do |room|
    config.client.join_room(room.to_s)

    users = config.client.get_room_members(room)[:chunk].select { |c| c[:content][:membership] == 'join' }
    next if users.count > 1

    STDERR.puts "[#{Time.now.strftime '%F %T'}] Room #{u[:room]} is empty, leaving."
    config.backends.each do |b|
      b.users.delete_if { |u| u[:room] == room }
    end

    config.client.leave_room(room)
  end

  STDERR.puts "[#{Time.now.strftime '%F %T'}] Starting tracker with #{config.backends.count} backends."
  loop do
    STDERR.puts "[#{Time.now.strftime '%F %T'}] Checking Matrix client..."
    config.client.sync(timeout: 30.0, set_presence: :offline, since: config.next_batch).tap do |data|
      config.next_batch = data[:next_batch]

      data[:rooms][:invite].each do |room_id, _invite|
        STDERR.puts "[#{Time.now.strftime '%F %T'}]   Invited to #{room_id}."

        next if config.backends.map { |_k, b| b.users.map { |u| u[:room] } }.flatten.uniq.count > 50

        STDERR.puts "[#{Time.now.strftime '%F %T'}]   Joining #{room_id}."
        config.client.join_room(room_id.to_s)
      end

      data[:rooms][:join].each do |room_id, join|
        join[:timeline][:events].select { |ev| ev[:type] == 'm.room.message' && ev[:content] && ev[:content][:msgtype] == 'm.text' }.each do |message|
          STDERR.puts "[#{Time.now.strftime '%F %T'}]   #{message[:sender]} in #{room_id}: #{message[:content][:body]}"

          next unless message[:content][:body].start_with? '!github '

          users = config.client.get_room_members(room_id)[:chunk].select { |c| c[:content][:membership] == 'join' }
          next if users.count > 2

          users = config.backends.find { |k, _v| k == :github }.last.users
          user = users.find { |u| u[:room] == room_id }

          gh_name = message[:content][:body][8..-1]
          next if user[:name] == gh_name

          if user
            user[:name] = gh_name.downcase
          else
            users << {
              name: gh_name.downcase,
              room: room_id.to_s
            }
          end

          config.client.send_notice(room_id.to_s, "Now tracking GitHub user '#{gh_name}'")
        end
      end
    end

    config.backends.each do |_k, b|
      STDERR.puts "[#{Time.now.strftime '%F %T'}] Polling backend #{b.name} with #{b.users.count} users..."
      b.users.each do |u|
        repos = b.stars(u[:name])
        releases = b.last_releases(u[:name])
        STDERR.puts "[#{Time.now.strftime '%F %T'}]  Tracking #{repos.count} repositories - #{releases[:releases].count} with releases, for #{u[:name]}."

        selected_releases = releases[:releases].reject { |_k, v| v.nil? || v.publish_date < (u[:last_check] || Time.new(0)) }
        selected_releases.each do |_name, rel|
          STDERR.puts "[#{Time.now.strftime '%F %T'}]    Posting notice about #{rel.full_name} #{rel.version}"
          rel.avatar_url = fix_media_url(rel.avatar_url, config) if rel.avatar_url
          config.client.send_message_event(
            u[:room],
            'm.room.message',
            msgtype: 'm.notice',
            body: rel.to_s(:markdown),
            formatted_body: rel.to_s(:html),
            format: 'org.matrix.custom.html'
          )
        end

        u[:last_check] = Time.now if selected_releases.any?
      end
    end

    config.save!
    STDERR.puts "[#{Time.now.strftime '%F %T'}] Finished polling, data saved."

    limits = config.backends.values.map(&:rate_limit)
    limits.each do |l|
      STDERR.puts "[#{Time.now.strftime '%F %T'}] Limit|#{l.backend.name} #{l.requests - l.remaining} / #{l.requests} used (resets in #{l.resets_in} seconds)"
    end
    limits = limits.select(&:near_limit)
    if limits.any?
      latest = limits.max(&:resets_in)

      STDERR.puts "[#{Time.now.strftime '%F %T'}] Backend limits almost reached for #{latest.backend.name}, sleeping for #{latest.resets_in / 60.0} minutes"
      sleep latest.resets_in
    else
      sleep 15 * 60
    end
  end
end
