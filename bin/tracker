#!/usr/bin/env ruby

require 'logging'
require 'matrix_releasetracker'
require 'net/http'

def fix_media_url(url, config)
  config.media[url] ||= begin
    data = Net::HTTP.get_response(URI(url))

    config.client.media_upload(data.body, data.content_type)[:content_uri] if data.is_a? Net::HTTPOK
  end
end

if $PROGRAM_NAME == __FILE__
  config = MatrixReleasetracker::Config.load!
  STDERR.puts "[#{Time.now.strftime '%F %T'}] Loaded configuration."

  # MatrixSdk.debug!
  Logging.logger['MatrixReleasetracker'].tap do |logger|
    logger.add_appenders Logging.appenders.stdout
    logger.level = :debug # :warn
  end

  STDERR.puts "[#{Time.now.strftime '%F %T'}] Ensuring configured rooms are joined."
  config.backends.map { |_k, b| b.users.map { |u| u[:room] } }.flatten.uniq.each do |room|
    config.client.join_room(room)
  end

  STDERR.puts "[#{Time.now.strftime '%F %T'}] Starting tracker with #{config.backends.count} backends."
  loop do
    config.backends.each do |_k, b|
      STDERR.puts "[#{Time.now.strftime '%F %T'}] Polling backend #{b.name} with #{b.users.count} users..."
      b.users.each do |u|
        repos = b.stars(u[:name])
        releases = b.last_releases(u[:name])
        STDERR.puts "[#{Time.now.strftime '%F %T'}]  Tracking #{repos.count} repositories - #{releases[:releases].count} with releases, for #{u[:name]}."

        releases[:releases].reject { |_k, v| v.nil? || v.publish_date < (releases[:last_check] || Time.new(0)) }.each do |_name, rel|
          STDERR.puts "[#{Time.now.strftime '%F %T'}]    Posting notice about #{rel.full_name} #{rel.version}"
          rel.avatar_url = fix_media_url(rel.avatar_url, config) if rel.avatar_url
          config.client.send_message_event(
            u[:room],
            'm.room.message',
            msgtype: 'm.notice',
            body: rel.to_s(:markdown),
            formatted_body: rel.to_s(:html),
            format: 'org.matrix.custom.html'
          )
        end
      end
    end

    config.save!
    STDERR.puts "[#{Time.now.strftime '%F %T'}] Finished polling, data saved."

    limits = config.backends.values.map(&:rate_limit)
    limits.each do |l|
      STDERR.puts "[#{Time.now.strftime '%F %T'}] Limit|#{l.backend.name} #{l.requests - l.remaining} / #{l.requests} used (resets in #{l.resets_in} seconds)"
    end
    limits = limits.select(&:near_limit)
    if limits.any?
      latest = limits.max(&:resets_in)

      STDERR.puts "[#{Time.now.strftime '%F %T'}] Backend limits almost reached for #{latest.backend.name}, sleeping for #{latest.resets_in / 60.0} minutes"
      sleep latest.resets_in
    else
      sleep 15 * 60
    end
  end
end
